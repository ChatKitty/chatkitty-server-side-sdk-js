/* tslint:disable */
/* eslint-disable */
/**
 * ChatKitty Platform API
 * Server-Side Platform API for ChatKitty. ChatKitty is the first complete chat platform; bringing together everything that\'s required to build real-time chat into Web and mobile apps.  Using JavaScript or TypeScript? [Check out our server-side SDK](https://chatkitty.github.io/chatkitty-server-side-sdk-js/) for the ChatKitty Platform API.
 *
 * The version of the OpenAPI document: 1.2.0
 * Contact: development@chatkitty.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Represents this ChatKitty application and can be used to configure the application.
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 64 bit integer identifier associated with this application
     * @type {number}
     * @memberof Application
     */
    id: number;
    /**
     * The name of the ChatKitty application
     * @type {string}
     * @memberof Application
     */
    name: string;
    /**
     * Unique string used as an API key for this application client-side
     * @type {string}
     * @memberof Application
     */
    key: string;
    /**
     * Map of arbiturary properties belonging to this application
     * @type {object}
     * @memberof Application
     */
    properties?: object;
    /**
     * 
     * @type {ApplicationLinks}
     * @memberof Application
     */
    _links?: ApplicationLinks;
}
/**
 * 
 * @export
 * @interface ApplicationLinks
 */
export interface ApplicationLinks {
    /**
     * 
     * @type {Link}
     * @memberof ApplicationLinks
     */
    self: Link;
    /**
     * 
     * @type {Link}
     * @memberof ApplicationLinks
     */
    users: Link;
    /**
     * 
     * @type {Link}
     * @memberof ApplicationLinks
     */
    channels: Link;
    /**
     * 
     * @type {Link}
     * @memberof ApplicationLinks
     */
    messages: Link;
    /**
     * 
     * @type {Link}
     * @memberof ApplicationLinks
     */
    findusers: Link;
    /**
     * 
     * @type {Link}
     * @memberof ApplicationLinks
     */
    findchannels: Link;
}
/**
 * A channel within this ChatKitty application
 * @export
 * @interface Channel
 */
export interface Channel {
    /**
     * 64 bit integer identifier associated with this channel
     * @type {number}
     * @memberof Channel
     */
    id: number;
    /**
     * The type of this channel
     * @type {string}
     * @memberof Channel
     */
    type: ChannelTypeEnum;
    /**
     * The unique name of this channel
     * @type {string}
     * @memberof Channel
     */
    name: string;
    /**
     * 
     * @type {Message}
     * @memberof Channel
     */
    lastReceivedMessage?: Message;
    /**
     * 
     * @type {User}
     * @memberof Channel
     */
    creator?: User;
    /**
     * Map of arbiturary properties belonging to this channel
     * @type {object}
     * @memberof Channel
     */
    properties?: object;
    /**
     * ISO 8601 instant when this channel was created
     * @type {string}
     * @memberof Channel
     */
    createdTime: string;
    /**
     * 
     * @type {ChannelLinks}
     * @memberof Channel
     */
    _links?: ChannelLinks;
}

/**
    * @export
    * @enum {string}
    */
export enum ChannelTypeEnum {
    Public = 'PUBLIC',
    Private = 'PRIVATE',
    Direct = 'DIRECT',
    Open = 'OPEN'
}

/**
 * 
 * @export
 * @interface ChannelLinks
 */
export interface ChannelLinks {
    /**
     * 
     * @type {Link}
     * @memberof ChannelLinks
     */
    self: Link;
    /**
     * 
     * @type {Link}
     * @memberof ChannelLinks
     */
    messages: Link;
    /**
     * 
     * @type {Link}
     * @memberof ChannelLinks
     */
    members?: Link;
    /**
     * 
     * @type {Link}
     * @memberof ChannelLinks
     */
    application: Link;
}
/**
 * A page of channels
 * @export
 * @interface ChannelPage
 */
export interface ChannelPage {
    /**
     * 
     * @type {ChannelPageAllOfEmbedded}
     * @memberof ChannelPage
     */
    _embedded: ChannelPageAllOfEmbedded;
    /**
     * 
     * @type {PagePage}
     * @memberof ChannelPage
     */
    page: PagePage;
    /**
     * 
     * @type {PageLinks}
     * @memberof ChannelPage
     */
    _links: PageLinks;
}
/**
 * 
 * @export
 * @interface ChannelPageAllOf
 */
export interface ChannelPageAllOf {
    /**
     * 
     * @type {ChannelPageAllOfEmbedded}
     * @memberof ChannelPageAllOf
     */
    _embedded?: ChannelPageAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface ChannelPageAllOfEmbedded
 */
export interface ChannelPageAllOfEmbedded {
    /**
     * 
     * @type {Array<Channel>}
     * @memberof ChannelPageAllOfEmbedded
     */
    channels?: Array<Channel>;
}
/**
 * 
 * @export
 * @interface CreateChannelRequest
 */
export interface CreateChannelRequest {
    /**
     * The type of this channel.
     * @type {string}
     * @memberof CreateChannelRequest
     */
    type: CreateChannelRequestTypeEnum;
    /**
     * Map of arbiturary properties belonging to this channel
     * @type {object}
     * @memberof CreateChannelRequest
     */
    properties?: object;
    /**
     * 
     * @type {ResourceReference}
     * @memberof CreateChannelRequest
     */
    creator?: ResourceReference;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateChannelRequestTypeEnum {
    Public = 'PUBLIC',
    Private = 'PRIVATE',
    Direct = 'DIRECT',
    Open = 'OPEN'
}

/**
 * 
 * @export
 * @interface CreateDirectChannelRequest
 */
export interface CreateDirectChannelRequest extends CreateChannelRequest {
    /**
     * Resource references of the members of this direct channel. The same direct channel is always returned for the same set of members.
     * @type {Array<ResourceReference>}
     * @memberof CreateDirectChannelRequest
     */
    members: Array<ResourceReference>;
}


/**
 * 
 * @export
 * @interface CreateExternalFileRequest
 */
export interface CreateExternalFileRequest {
    /**
     * External URL pointing to this file\'s content
     * @type {string}
     * @memberof CreateExternalFileRequest
     */
    url: string;
    /**
     * The name of this file
     * @type {string}
     * @memberof CreateExternalFileRequest
     */
    name: string;
    /**
     * MIME type of this file
     * @type {string}
     * @memberof CreateExternalFileRequest
     */
    contentType: string;
    /**
     * 
     * @type {number}
     * @memberof CreateExternalFileRequest
     */
    size: number;
}
/**
 * 
 * @export
 * @interface CreateExternalFileSystemMessageRequest
 */
export interface CreateExternalFileSystemMessageRequest {
    /**
     * The type of message. Always FILE
     * @type {string}
     * @memberof CreateExternalFileSystemMessageRequest
     */
    type: CreateExternalFileSystemMessageRequestTypeEnum;
    /**
     * 
     * @type {CreateExternalFileRequest}
     * @memberof CreateExternalFileSystemMessageRequest
     */
    file: CreateExternalFileRequest;
    /**
     * Tag to group file messages by (like an album name).
     * @type {string}
     * @memberof CreateExternalFileSystemMessageRequest
     */
    groupTag?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateExternalFileSystemMessageRequestTypeEnum {
    File = 'FILE'
}

/**
 * 
 * @export
 * @interface CreateOpenChannelRequest
 */
export interface CreateOpenChannelRequest extends CreateChannelRequest {
    /**
     * A unique name for the channel.
     * @type {string}
     * @memberof CreateOpenChannelRequest
     */
    name?: string;
}


/**
 * 
 * @export
 * @interface CreatePrivateChannelRequest
 */
export interface CreatePrivateChannelRequest extends CreateChannelRequest {
    /**
     * A unique name for the channel.
     * @type {string}
     * @memberof CreatePrivateChannelRequest
     */
    name?: string;
}


/**
 * 
 * @export
 * @interface CreatePublicChannelRequest
 */
export interface CreatePublicChannelRequest extends CreateChannelRequest {
    /**
     * A unique name for the channel.
     * @type {string}
     * @memberof CreatePublicChannelRequest
     */
    name?: string;
}


/**
 * 
 * @export
 * @interface CreateTextSystemMessageRequest
 */
export interface CreateTextSystemMessageRequest {
    /**
     * The type of message. Always TEXT
     * @type {string}
     * @memberof CreateTextSystemMessageRequest
     */
    type: CreateTextSystemMessageRequestTypeEnum;
    /**
     * The text body of the message.
     * @type {string}
     * @memberof CreateTextSystemMessageRequest
     */
    body: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateTextSystemMessageRequestTypeEnum {
    Text = 'TEXT'
}

/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * Username of this user
     * @type {string}
     * @memberof CreateUserRequest
     */
    name: string;
    /**
     * Human readable name of this user that will be shown to other users
     * @type {string}
     * @memberof CreateUserRequest
     */
    displayName: string;
    /**
     * True if this user should be created as a guest
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    isGuest?: boolean;
}
/**
 * Represents a HAL HATEOAS link to a resource
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * URI pointing to a resource representation
     * @type {string}
     * @memberof Link
     */
    href: string;
}
/**
 * A message within this ChatKitty application
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 64 bit integer identifier associated with this message. Present if this message is persistent
     * @type {number}
     * @memberof Message
     */
    id?: number;
    /**
     * The type of this message
     * @type {string}
     * @memberof Message
     */
    type: MessageTypeEnum;
    /**
     * 
     * @type {User}
     * @memberof Message
     */
    user?: User;
    /**
     * Text body of this message. Present if this is a text message
     * @type {string}
     * @memberof Message
     */
    body?: string;
    /**
     * 
     * @type {any}
     * @memberof Message
     */
    file?: any;
    /**
     * Map of arbiturary properties belonging to this message
     * @type {object}
     * @memberof Message
     */
    properties?: object;
    /**
     * ISO 8601 instant when this message was created
     * @type {string}
     * @memberof Message
     */
    createdTime: string;
    /**
     * 
     * @type {MessageLinks}
     * @memberof Message
     */
    _links?: MessageLinks;
}

/**
    * @export
    * @enum {string}
    */
export enum MessageTypeEnum {
    Text = 'TEXT',
    File = 'FILE',
    SystemText = 'SYSTEM_TEXT',
    SystemFile = 'SYSTEM_FILE'
}

/**
 * 
 * @export
 * @interface MessageLinks
 */
export interface MessageLinks {
    /**
     * 
     * @type {Link}
     * @memberof MessageLinks
     */
    self: Link;
    /**
     * 
     * @type {Link}
     * @memberof MessageLinks
     */
    channel: Link;
    /**
     * 
     * @type {Link}
     * @memberof MessageLinks
     */
    user?: Link;
    /**
     * 
     * @type {Link}
     * @memberof MessageLinks
     */
    application: Link;
}
/**
 * A page of messages
 * @export
 * @interface MessagePage
 */
export interface MessagePage {
    /**
     * 
     * @type {MessagePageAllOfEmbedded}
     * @memberof MessagePage
     */
    _embedded: MessagePageAllOfEmbedded;
    /**
     * 
     * @type {PagePage}
     * @memberof MessagePage
     */
    page: PagePage;
    /**
     * 
     * @type {PageLinks}
     * @memberof MessagePage
     */
    _links: PageLinks;
}
/**
 * 
 * @export
 * @interface MessagePageAllOf
 */
export interface MessagePageAllOf {
    /**
     * 
     * @type {MessagePageAllOfEmbedded}
     * @memberof MessagePageAllOf
     */
    _embedded?: MessagePageAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface MessagePageAllOfEmbedded
 */
export interface MessagePageAllOfEmbedded {
    /**
     * 
     * @type {Array<Message>}
     * @memberof MessagePageAllOfEmbedded
     */
    messages?: Array<Message>;
}
/**
 * File metadata
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * The type of this file
     * @type {string}
     * @memberof ModelFile
     */
    type: ModelFileTypeEnum;
    /**
     * URI pointing to this file\'s content
     * @type {string}
     * @memberof ModelFile
     */
    url: string;
    /**
     * The name of this file
     * @type {string}
     * @memberof ModelFile
     */
    name: string;
    /**
     * MIME type of this file
     * @type {string}
     * @memberof ModelFile
     */
    contentType: string;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    size: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ModelFileTypeEnum {
    Hosted = 'HOSTED',
    External = 'EXTERNAL'
}

/**
 * A notification received by a ChatKitty user. The user receiving a notification is referred to as the notification recipient.
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 64 bit integer identifier associated with this notification
     * @type {number}
     * @memberof Notification
     */
    id: number;
    /**
     * Title of this notification briefly informing the user what occurred.
     * @type {string}
     * @memberof Notification
     */
    title: string;
    /**
     * Detailed message informing the user what occurred triggering this notification.
     * @type {string}
     * @memberof Notification
     */
    body: string;
    /**
     * 
     * @type {NotificationData}
     * @memberof Notification
     */
    data: NotificationData;
    /**
     * True if this notification is muted and should not actively notify the receipient user of its related event.
     * @type {boolean}
     * @memberof Notification
     */
    muted?: boolean;
    /**
     * ISO 8601 instant when this notification was created
     * @type {string}
     * @memberof Notification
     */
    createdTime: string;
    /**
     * ISO 8601 instant when this notification was first read.
     * @type {string}
     * @memberof Notification
     */
    readTime?: string;
    /**
     * 
     * @type {NotificationLinks}
     * @memberof Notification
     */
    _links?: NotificationLinks;
}
/**
 * Additional data related to a notification.
 * @export
 * @interface NotificationData
 */
export interface NotificationData {
    /**
     * The type of notification that was received. This specifies the schema of the notification data.
     * @type {string}
     * @memberof NotificationData
     */
    type: NotificationDataTypeEnum;
    /**
     * 64 bit integer identifier associated with the channel this notification is related to. Present if SYSTEM:SENT:MESSAGE, or USER:SENT:MESSAGE.
     * @type {number}
     * @memberof NotificationData
     */
    channelId?: number;
    /**
     * The message this notification is related to. Present if SYSTEM:SENT:MESSAGE, or USER:SENT:MESSAGE.
     * @type {Message}
     * @memberof NotificationData
     */
    message?: Message;
}

/**
    * @export
    * @enum {string}
    */
export enum NotificationDataTypeEnum {
    Systemsentmessage = 'SYSTEM:SENT:MESSAGE',
    Usersentmessage = 'USER:SENT:MESSAGE'
}

/**
 * 
 * @export
 * @interface NotificationLinks
 */
export interface NotificationLinks {
    /**
     * 
     * @type {Link}
     * @memberof NotificationLinks
     */
    self: Link;
    /**
     * 
     * @type {Link}
     * @memberof NotificationLinks
     */
    recipient: Link;
}
/**
 * A page of resources
 * @export
 * @interface Page
 */
export interface Page {
    /**
     * 
     * @type {PagePage}
     * @memberof Page
     */
    page: PagePage;
    /**
     * 
     * @type {PageLinks}
     * @memberof Page
     */
    _links: PageLinks;
}
/**
 * 
 * @export
 * @interface PageLinks
 */
export interface PageLinks {
    /**
     * 
     * @type {Link}
     * @memberof PageLinks
     */
    self: Link;
    /**
     * 
     * @type {Link}
     * @memberof PageLinks
     */
    first?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PageLinks
     */
    prev?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PageLinks
     */
    next?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PageLinks
     */
    last?: Link;
}
/**
 * 
 * @export
 * @interface PagePage
 */
export interface PagePage {
    /**
     * 
     * @type {number}
     * @memberof PagePage
     */
    size: number;
    /**
     * 
     * @type {number}
     * @memberof PagePage
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof PagePage
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PagePage
     */
    totalPages?: number;
}
/**
 * represents a message thread inside a channel
 * @export
 * @interface ReplyThread
 */
export interface ReplyThread {
    /**
     * 64 bit integer identifier associated with this reply thread
     * @type {number}
     * @memberof ReplyThread
     */
    id: number;
    /**
     * The type of this thread
     * @type {string}
     * @memberof ReplyThread
     */
    type: ReplyThreadTypeEnum;
    /**
     * 
     * @type {ReplyThreadLinks}
     * @memberof ReplyThread
     */
    _links?: ReplyThreadLinks;
}

/**
    * @export
    * @enum {string}
    */
export enum ReplyThreadTypeEnum {
    Main = 'MAIN',
    Child = 'CHILD'
}

/**
 * 
 * @export
 * @interface ReplyThreadLinks
 */
export interface ReplyThreadLinks {
    /**
     * 
     * @type {Link}
     * @memberof ReplyThreadLinks
     */
    self: Link;
    /**
     * 
     * @type {Link}
     * @memberof ReplyThreadLinks
     */
    application: Link;
}
/**
 * Represents a ChatKitty resources
 * @export
 * @interface ResourceReference
 */
export interface ResourceReference {
    /**
     * 64 bit integer identifier associated with the resource referenced
     * @type {number}
     * @memberof ResourceReference
     */
    id: number;
}
/**
 * Holds a server-side secret only accessible using the platform API
 * @export
 * @interface Secret
 */
export interface Secret {
    /**
     * The secret value
     * @type {any}
     * @memberof Secret
     */
    secret: any | null;
}
/**
 * A user within this ChatKitty application
 * @export
 * @interface User
 */
export interface User {
    /**
     * 64 bit integer identifier associated with this user
     * @type {number}
     * @memberof User
     */
    id: number;
    /**
     * The unique name of the user - the username
     * @type {string}
     * @memberof User
     */
    name: string;
    /**
     * Human readable name of this user that will be shown to other user
     * @type {string}
     * @memberof User
     */
    displayName: string;
    /**
     * URI to this user\'s avatar image
     * @type {string}
     * @memberof User
     */
    displayPictureUrl: string;
    /**
     * Included if this user was created as a guest
     * @type {boolean}
     * @memberof User
     */
    isGuest?: boolean;
    /**
     * Map of arbiturary properties belonging to this user
     * @type {object}
     * @memberof User
     */
    properties?: object;
    /**
     * 
     * @type {UserLinks}
     * @memberof User
     */
    _links?: UserLinks;
}
/**
 * 
 * @export
 * @interface UserLinks
 */
export interface UserLinks {
    /**
     * 
     * @type {Link}
     * @memberof UserLinks
     */
    self: Link;
}
/**
 * A page of users
 * @export
 * @interface UserPage
 */
export interface UserPage {
    /**
     * 
     * @type {UserPageAllOfEmbedded}
     * @memberof UserPage
     */
    _embedded: UserPageAllOfEmbedded;
    /**
     * 
     * @type {PagePage}
     * @memberof UserPage
     */
    page: PagePage;
    /**
     * 
     * @type {PageLinks}
     * @memberof UserPage
     */
    _links: PageLinks;
}
/**
 * 
 * @export
 * @interface UserPageAllOf
 */
export interface UserPageAllOf {
    /**
     * 
     * @type {UserPageAllOfEmbedded}
     * @memberof UserPageAllOf
     */
    _embedded?: UserPageAllOfEmbedded;
}
/**
 * 
 * @export
 * @interface UserPageAllOfEmbedded
 */
export interface UserPageAllOfEmbedded {
    /**
     * 
     * @type {Array<User>}
     * @memberof UserPageAllOfEmbedded
     */
    users?: Array<User>;
}

/**
 * ApplicationApi - axios parameter creator
 * @export
 */
export const ApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets this ChatKitty application.
         * @summary Get Application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationApi - functional programming interface
 * @export
 */
export const ApplicationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets this ChatKitty application.
         * @summary Get Application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await ApplicationApiAxiosParamCreator(configuration).getApplication(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ApplicationApi - factory interface
 * @export
 */
export const ApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Gets this ChatKitty application.
         * @summary Get Application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(options?: any): AxiosPromise<Application> {
            return ApplicationApiFp(configuration).getApplication(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationApi - object-oriented interface
 * @export
 * @class ApplicationApi
 * @extends {BaseAPI}
 */
export class ApplicationApi extends BaseAPI {
    /**
     * Gets this ChatKitty application.
     * @summary Get Application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getApplication(options?: any) {
        return ApplicationApiFp(this.configuration).getApplication(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChannelApi - axios parameter creator
 * @export
 */
export const ChannelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new channel.
         * @summary Create Channel
         * @param {CreatePublicChannelRequest | CreatePrivateChannelRequest | CreateDirectChannelRequest | CreateOpenChannelRequest} createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest New channel parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannel: async (createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest: CreatePublicChannelRequest | CreatePrivateChannelRequest | CreateDirectChannelRequest | CreateOpenChannelRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest' is not null or undefined
            if (createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest === null || createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest === undefined) {
                throw new RequiredError('createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest','Required parameter createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest was null or undefined when calling createChannel.');
            }
            const localVarPath = `/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest !== undefined ? createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest : {})
                : (createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a user as a group channel member.
         * @summary Create Channel Member
         * @param {number} id 
         * @param {ResourceReference} resourceReference User resource reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelMember: async (id: number, resourceReference: ResourceReference, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createChannelMember.');
            }
            // verify required parameter 'resourceReference' is not null or undefined
            if (resourceReference === null || resourceReference === undefined) {
                throw new RequiredError('resourceReference','Required parameter resourceReference was null or undefined when calling createChannelMember.');
            }
            const localVarPath = `/channels/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof resourceReference !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(resourceReference !== undefined ? resourceReference : {})
                : (resourceReference || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a new system message.
         * @summary Create Channel System Message
         * @param {number} id 
         * @param {CreateTextSystemMessageRequest | CreateExternalFileSystemMessageRequest} createTextSystemMessageRequestCreateExternalFileSystemMessageRequest New message parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelMessage: async (id: number, createTextSystemMessageRequestCreateExternalFileSystemMessageRequest: CreateTextSystemMessageRequest | CreateExternalFileSystemMessageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createChannelMessage.');
            }
            // verify required parameter 'createTextSystemMessageRequestCreateExternalFileSystemMessageRequest' is not null or undefined
            if (createTextSystemMessageRequestCreateExternalFileSystemMessageRequest === null || createTextSystemMessageRequestCreateExternalFileSystemMessageRequest === undefined) {
                throw new RequiredError('createTextSystemMessageRequestCreateExternalFileSystemMessageRequest','Required parameter createTextSystemMessageRequestCreateExternalFileSystemMessageRequest was null or undefined when calling createChannelMessage.');
            }
            const localVarPath = `/channels/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof createTextSystemMessageRequestCreateExternalFileSystemMessageRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(createTextSystemMessageRequestCreateExternalFileSystemMessageRequest !== undefined ? createTextSystemMessageRequestCreateExternalFileSystemMessageRequest : {})
                : (createTextSystemMessageRequestCreateExternalFileSystemMessageRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a channel.
         * @summary Delete Channel
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteChannel.');
            }
            const localVarPath = `/channels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a user\'s channel membership. Removes a user from a channel.
         * @summary Delete Channel Membership
         * @param {number} id Channel ID
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannelMembership: async (id: number, userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteChannelMembership.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteChannelMembership.');
            }
            const localVarPath = `/channels/{id}/members/{userId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a channel.
         * @summary Get Channel
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getChannel.');
            }
            const localVarPath = `/channels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a page of channel members.
         * @summary Get Channel Members
         * @param {number} id 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelMembers: async (id: number, page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getChannelMembers.');
            }
            const localVarPath = `/channels/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a page of channel messages.
         * @summary Get Channel Messages
         * @param {number} id 
         * @param {number} [start] 
         * @param {number} [next] 
         * @param {number} [size] 
         * @param {'SELF' | 'PREVIOUS' | 'NEXT'} [relation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelMessages: async (id: number, start?: number, next?: number, size?: number, relation?: 'SELF' | 'PREVIOUS' | 'NEXT', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getChannelMessages.');
            }
            const localVarPath = `/channels/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a channel page.
         * @summary Get Channel Page
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels: async (page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelApi - functional programming interface
 * @export
 */
export const ChannelApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new channel.
         * @summary Create Channel
         * @param {CreatePublicChannelRequest | CreatePrivateChannelRequest | CreateDirectChannelRequest | CreateOpenChannelRequest} createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest New channel parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChannel(createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest: CreatePublicChannelRequest | CreatePrivateChannelRequest | CreateDirectChannelRequest | CreateOpenChannelRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Channel>> {
            const localVarAxiosArgs = await ChannelApiAxiosParamCreator(configuration).createChannel(createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds a user as a group channel member.
         * @summary Create Channel Member
         * @param {number} id 
         * @param {ResourceReference} resourceReference User resource reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChannelMember(id: number, resourceReference: ResourceReference, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await ChannelApiAxiosParamCreator(configuration).createChannelMember(id, resourceReference, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sends a new system message.
         * @summary Create Channel System Message
         * @param {number} id 
         * @param {CreateTextSystemMessageRequest | CreateExternalFileSystemMessageRequest} createTextSystemMessageRequestCreateExternalFileSystemMessageRequest New message parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChannelMessage(id: number, createTextSystemMessageRequestCreateExternalFileSystemMessageRequest: CreateTextSystemMessageRequest | CreateExternalFileSystemMessageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await ChannelApiAxiosParamCreator(configuration).createChannelMessage(id, createTextSystemMessageRequestCreateExternalFileSystemMessageRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a channel.
         * @summary Delete Channel
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChannel(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await ChannelApiAxiosParamCreator(configuration).deleteChannel(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a user\'s channel membership. Removes a user from a channel.
         * @summary Delete Channel Membership
         * @param {number} id Channel ID
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChannelMembership(id: number, userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Channel>> {
            const localVarAxiosArgs = await ChannelApiAxiosParamCreator(configuration).deleteChannelMembership(id, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a channel.
         * @summary Get Channel
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Channel>> {
            const localVarAxiosArgs = await ChannelApiAxiosParamCreator(configuration).getChannel(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a page of channel members.
         * @summary Get Channel Members
         * @param {number} id 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelMembers(id: number, page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPage>> {
            const localVarAxiosArgs = await ChannelApiAxiosParamCreator(configuration).getChannelMembers(id, page, size, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a page of channel messages.
         * @summary Get Channel Messages
         * @param {number} id 
         * @param {number} [start] 
         * @param {number} [next] 
         * @param {number} [size] 
         * @param {'SELF' | 'PREVIOUS' | 'NEXT'} [relation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelMessages(id: number, start?: number, next?: number, size?: number, relation?: 'SELF' | 'PREVIOUS' | 'NEXT', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessagePage>> {
            const localVarAxiosArgs = await ChannelApiAxiosParamCreator(configuration).getChannelMessages(id, start, next, size, relation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a channel page.
         * @summary Get Channel Page
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannels(page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelPage>> {
            const localVarAxiosArgs = await ChannelApiAxiosParamCreator(configuration).getChannels(page, size, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ChannelApi - factory interface
 * @export
 */
export const ChannelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new channel.
         * @summary Create Channel
         * @param {CreatePublicChannelRequest | CreatePrivateChannelRequest | CreateDirectChannelRequest | CreateOpenChannelRequest} createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest New channel parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannel(createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest: CreatePublicChannelRequest | CreatePrivateChannelRequest | CreateDirectChannelRequest | CreateOpenChannelRequest, options?: any): AxiosPromise<Channel> {
            return ChannelApiFp(configuration).createChannel(createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a user as a group channel member.
         * @summary Create Channel Member
         * @param {number} id 
         * @param {ResourceReference} resourceReference User resource reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelMember(id: number, resourceReference: ResourceReference, options?: any): AxiosPromise<User> {
            return ChannelApiFp(configuration).createChannelMember(id, resourceReference, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a new system message.
         * @summary Create Channel System Message
         * @param {number} id 
         * @param {CreateTextSystemMessageRequest | CreateExternalFileSystemMessageRequest} createTextSystemMessageRequestCreateExternalFileSystemMessageRequest New message parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelMessage(id: number, createTextSystemMessageRequestCreateExternalFileSystemMessageRequest: CreateTextSystemMessageRequest | CreateExternalFileSystemMessageRequest, options?: any): AxiosPromise<Message> {
            return ChannelApiFp(configuration).createChannelMessage(id, createTextSystemMessageRequestCreateExternalFileSystemMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a channel.
         * @summary Delete Channel
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel(id: number, options?: any): AxiosPromise<Application> {
            return ChannelApiFp(configuration).deleteChannel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a user\'s channel membership. Removes a user from a channel.
         * @summary Delete Channel Membership
         * @param {number} id Channel ID
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannelMembership(id: number, userId: number, options?: any): AxiosPromise<Channel> {
            return ChannelApiFp(configuration).deleteChannelMembership(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a channel.
         * @summary Get Channel
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(id: number, options?: any): AxiosPromise<Channel> {
            return ChannelApiFp(configuration).getChannel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a page of channel members.
         * @summary Get Channel Members
         * @param {number} id 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelMembers(id: number, page?: number, size?: number, options?: any): AxiosPromise<UserPage> {
            return ChannelApiFp(configuration).getChannelMembers(id, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a page of channel messages.
         * @summary Get Channel Messages
         * @param {number} id 
         * @param {number} [start] 
         * @param {number} [next] 
         * @param {number} [size] 
         * @param {'SELF' | 'PREVIOUS' | 'NEXT'} [relation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelMessages(id: number, start?: number, next?: number, size?: number, relation?: 'SELF' | 'PREVIOUS' | 'NEXT', options?: any): AxiosPromise<MessagePage> {
            return ChannelApiFp(configuration).getChannelMessages(id, start, next, size, relation, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a channel page.
         * @summary Get Channel Page
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(page?: number, size?: number, options?: any): AxiosPromise<ChannelPage> {
            return ChannelApiFp(configuration).getChannels(page, size, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChannelApi - object-oriented interface
 * @export
 * @class ChannelApi
 * @extends {BaseAPI}
 */
export class ChannelApi extends BaseAPI {
    /**
     * Creates a new channel.
     * @summary Create Channel
     * @param {CreatePublicChannelRequest | CreatePrivateChannelRequest | CreateDirectChannelRequest | CreateOpenChannelRequest} createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest New channel parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public createChannel(createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest: CreatePublicChannelRequest | CreatePrivateChannelRequest | CreateDirectChannelRequest | CreateOpenChannelRequest, options?: any) {
        return ChannelApiFp(this.configuration).createChannel(createPublicChannelRequestCreatePrivateChannelRequestCreateDirectChannelRequestCreateOpenChannelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a user as a group channel member.
     * @summary Create Channel Member
     * @param {number} id 
     * @param {ResourceReference} resourceReference User resource reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public createChannelMember(id: number, resourceReference: ResourceReference, options?: any) {
        return ChannelApiFp(this.configuration).createChannelMember(id, resourceReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a new system message.
     * @summary Create Channel System Message
     * @param {number} id 
     * @param {CreateTextSystemMessageRequest | CreateExternalFileSystemMessageRequest} createTextSystemMessageRequestCreateExternalFileSystemMessageRequest New message parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public createChannelMessage(id: number, createTextSystemMessageRequestCreateExternalFileSystemMessageRequest: CreateTextSystemMessageRequest | CreateExternalFileSystemMessageRequest, options?: any) {
        return ChannelApiFp(this.configuration).createChannelMessage(id, createTextSystemMessageRequestCreateExternalFileSystemMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a channel.
     * @summary Delete Channel
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public deleteChannel(id: number, options?: any) {
        return ChannelApiFp(this.configuration).deleteChannel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a user\'s channel membership. Removes a user from a channel.
     * @summary Delete Channel Membership
     * @param {number} id Channel ID
     * @param {number} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public deleteChannelMembership(id: number, userId: number, options?: any) {
        return ChannelApiFp(this.configuration).deleteChannelMembership(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a channel.
     * @summary Get Channel
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public getChannel(id: number, options?: any) {
        return ChannelApiFp(this.configuration).getChannel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a page of channel members.
     * @summary Get Channel Members
     * @param {number} id 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public getChannelMembers(id: number, page?: number, size?: number, options?: any) {
        return ChannelApiFp(this.configuration).getChannelMembers(id, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a page of channel messages.
     * @summary Get Channel Messages
     * @param {number} id 
     * @param {number} [start] 
     * @param {number} [next] 
     * @param {number} [size] 
     * @param {'SELF' | 'PREVIOUS' | 'NEXT'} [relation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public getChannelMessages(id: number, start?: number, next?: number, size?: number, relation?: 'SELF' | 'PREVIOUS' | 'NEXT', options?: any) {
        return ChannelApiFp(this.configuration).getChannelMessages(id, start, next, size, relation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a channel page.
     * @summary Get Channel Page
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public getChannels(page?: number, size?: number, options?: any) {
        return ChannelApiFp(this.configuration).getChannels(page, size, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MessageApi - axios parameter creator
 * @export
 */
export const MessageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a message.
         * @summary Delete Message
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteMessage.');
            }
            const localVarPath = `/messages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a message.
         * @summary Get Message
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getMessage.');
            }
            const localVarPath = `/messages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a page of messages.
         * @summary Get Messages
         * @param {number} [start] 
         * @param {number} [next] 
         * @param {number} [size] 
         * @param {'SELF' | 'PREVIOUS' | 'NEXT'} [relation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages: async (start?: number, next?: number, size?: number, relation?: 'SELF' | 'PREVIOUS' | 'NEXT', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageApi - functional programming interface
 * @export
 */
export const MessageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a message.
         * @summary Delete Message
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessage(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReplyThread>> {
            const localVarAxiosArgs = await MessageApiAxiosParamCreator(configuration).deleteMessage(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a message.
         * @summary Get Message
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessage(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await MessageApiAxiosParamCreator(configuration).getMessage(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a page of messages.
         * @summary Get Messages
         * @param {number} [start] 
         * @param {number} [next] 
         * @param {number} [size] 
         * @param {'SELF' | 'PREVIOUS' | 'NEXT'} [relation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessages(start?: number, next?: number, size?: number, relation?: 'SELF' | 'PREVIOUS' | 'NEXT', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessagePage>> {
            const localVarAxiosArgs = await MessageApiAxiosParamCreator(configuration).getMessages(start, next, size, relation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MessageApi - factory interface
 * @export
 */
export const MessageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes a message.
         * @summary Delete Message
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(id: number, options?: any): AxiosPromise<ReplyThread> {
            return MessageApiFp(configuration).deleteMessage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a message.
         * @summary Get Message
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(id: number, options?: any): AxiosPromise<Message> {
            return MessageApiFp(configuration).getMessage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a page of messages.
         * @summary Get Messages
         * @param {number} [start] 
         * @param {number} [next] 
         * @param {number} [size] 
         * @param {'SELF' | 'PREVIOUS' | 'NEXT'} [relation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(start?: number, next?: number, size?: number, relation?: 'SELF' | 'PREVIOUS' | 'NEXT', options?: any): AxiosPromise<MessagePage> {
            return MessageApiFp(configuration).getMessages(start, next, size, relation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
export class MessageApi extends BaseAPI {
    /**
     * Deletes a message.
     * @summary Delete Message
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public deleteMessage(id: number, options?: any) {
        return MessageApiFp(this.configuration).deleteMessage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a message.
     * @summary Get Message
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public getMessage(id: number, options?: any) {
        return MessageApiFp(this.configuration).getMessage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a page of messages.
     * @summary Get Messages
     * @param {number} [start] 
     * @param {number} [next] 
     * @param {number} [size] 
     * @param {'SELF' | 'PREVIOUS' | 'NEXT'} [relation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public getMessages(start?: number, next?: number, size?: number, relation?: 'SELF' | 'PREVIOUS' | 'NEXT', options?: any) {
        return MessageApiFp(this.configuration).getMessages(start, next, size, relation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new ChatKitty user.
         * @summary Create User
         * @param {CreateUserRequest} createUserRequest New user parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequest: CreateUserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            if (createUserRequest === null || createUserRequest === undefined) {
                throw new RequiredError('createUserRequest','Required parameter createUserRequest was null or undefined when calling createUser.');
            }
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof createUserRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(createUserRequest !== undefined ? createUserRequest : {})
                : (createUserRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a user.
         * @summary Delete User
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a user.
         * @summary Delete User Secret
         * @param {number} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserSecret: async (id: number, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteUserSecret.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteUserSecret.');
            }
            const localVarPath = `/users/{id}/secrets/{name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a user.
         * @summary Get User
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUser.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if a user exists.
         * @summary Get User Exists
         * @param {string} name The username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserExists: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getUserExists.');
            }
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a user sceret.
         * @summary Get User Secret
         * @param {number} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSecret: async (id: number, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUserSecret.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getUserSecret.');
            }
            const localVarPath = `/users/{id}/secrets/{name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a user page.
         * @summary Get User Page
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [name] The username of a user to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (page?: number, size?: number, name?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a ChatKitty user.
         * @summary Update User
         * @param {number} id 
         * @param {User} user ChatKitty user with properties to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: number, user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateUser.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling updateUser.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof user !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(user !== undefined ? user : {})
                : (user || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Puts a user secret.
         * @summary Update User Secret
         * @param {number} id 
         * @param {string} name 
         * @param {Secret} secret Secret value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSecret: async (id: number, name: string, secret: Secret, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateUserSecret.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateUserSecret.');
            }
            // verify required parameter 'secret' is not null or undefined
            if (secret === null || secret === undefined) {
                throw new RequiredError('secret','Required parameter secret was null or undefined when calling updateUserSecret.');
            }
            const localVarPath = `/users/{id}/secrets/{name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof secret !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(secret !== undefined ? secret : {})
                : (secret || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new ChatKitty user.
         * @summary Create User
         * @param {CreateUserRequest} createUserRequest New user parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequest: CreateUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).createUser(createUserRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a user.
         * @summary Delete User
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).deleteUser(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes a user.
         * @summary Delete User Secret
         * @param {number} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserSecret(id: number, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).deleteUserSecret(id, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a user.
         * @summary Get User
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUser(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Checks if a user exists.
         * @summary Get User Exists
         * @param {string} name The username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserExists(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUserExists(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a user sceret.
         * @summary Get User Secret
         * @param {number} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSecret(id: number, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUserSecret(id, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a user page.
         * @summary Get User Page
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [name] The username of a user to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(page?: number, size?: number, name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPage>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUsers(page, size, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a ChatKitty user.
         * @summary Update User
         * @param {number} id 
         * @param {User} user ChatKitty user with properties to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: number, user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUser(id, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Puts a user secret.
         * @summary Update User Secret
         * @param {number} id 
         * @param {string} name 
         * @param {Secret} secret Secret value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSecret(id: number, name: string, secret: Secret, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUserSecret(id, name, secret, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new ChatKitty user.
         * @summary Create User
         * @param {CreateUserRequest} createUserRequest New user parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest: CreateUserRequest, options?: any): AxiosPromise<User> {
            return UserApiFp(configuration).createUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a user.
         * @summary Delete User
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: number, options?: any): AxiosPromise<Application> {
            return UserApiFp(configuration).deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a user.
         * @summary Delete User Secret
         * @param {number} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserSecret(id: number, name: string, options?: any): AxiosPromise<User> {
            return UserApiFp(configuration).deleteUserSecret(id, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a user.
         * @summary Get User
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: number, options?: any): AxiosPromise<User> {
            return UserApiFp(configuration).getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if a user exists.
         * @summary Get User Exists
         * @param {string} name The username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserExists(name: string, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).getUserExists(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a user sceret.
         * @summary Get User Secret
         * @param {number} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSecret(id: number, name: string, options?: any): AxiosPromise<Secret> {
            return UserApiFp(configuration).getUserSecret(id, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a user page.
         * @summary Get User Page
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [name] The username of a user to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(page?: number, size?: number, name?: string, options?: any): AxiosPromise<UserPage> {
            return UserApiFp(configuration).getUsers(page, size, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a ChatKitty user.
         * @summary Update User
         * @param {number} id 
         * @param {User} user ChatKitty user with properties to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, user: User, options?: any): AxiosPromise<User> {
            return UserApiFp(configuration).updateUser(id, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Puts a user secret.
         * @summary Update User Secret
         * @param {number} id 
         * @param {string} name 
         * @param {Secret} secret Secret value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSecret(id: number, name: string, secret: Secret, options?: any): AxiosPromise<User> {
            return UserApiFp(configuration).updateUserSecret(id, name, secret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Creates a new ChatKitty user.
     * @summary Create User
     * @param {CreateUserRequest} createUserRequest New user parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(createUserRequest: CreateUserRequest, options?: any) {
        return UserApiFp(this.configuration).createUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a user.
     * @summary Delete User
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(id: number, options?: any) {
        return UserApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a user.
     * @summary Delete User Secret
     * @param {number} id 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUserSecret(id: number, name: string, options?: any) {
        return UserApiFp(this.configuration).deleteUserSecret(id, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a user.
     * @summary Get User
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(id: number, options?: any) {
        return UserApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if a user exists.
     * @summary Get User Exists
     * @param {string} name The username of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserExists(name: string, options?: any) {
        return UserApiFp(this.configuration).getUserExists(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a user sceret.
     * @summary Get User Secret
     * @param {number} id 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserSecret(id: number, name: string, options?: any) {
        return UserApiFp(this.configuration).getUserSecret(id, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a user page.
     * @summary Get User Page
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [name] The username of a user to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(page?: number, size?: number, name?: string, options?: any) {
        return UserApiFp(this.configuration).getUsers(page, size, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a ChatKitty user.
     * @summary Update User
     * @param {number} id 
     * @param {User} user ChatKitty user with properties to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(id: number, user: User, options?: any) {
        return UserApiFp(this.configuration).updateUser(id, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Puts a user secret.
     * @summary Update User Secret
     * @param {number} id 
     * @param {string} name 
     * @param {Secret} secret Secret value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserSecret(id: number, name: string, secret: Secret, options?: any) {
        return UserApiFp(this.configuration).updateUserSecret(id, name, secret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserSessionApi - axios parameter creator
 * @export
 */
export const UserSessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks if an active user session exists.
         * @summary Get Active User Session Exists
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveSessionExists: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getActiveSessionExists.');
            }
            const localVarPath = `/user_sessions/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatkittyPlatformAuthorization required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("chatkittyPlatformAuthorization", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSessionApi - functional programming interface
 * @export
 */
export const UserSessionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Checks if an active user session exists.
         * @summary Get Active User Session Exists
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveSessionExists(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserSessionApiAxiosParamCreator(configuration).getActiveSessionExists(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserSessionApi - factory interface
 * @export
 */
export const UserSessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Checks if an active user session exists.
         * @summary Get Active User Session Exists
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveSessionExists(id: number, options?: any): AxiosPromise<void> {
            return UserSessionApiFp(configuration).getActiveSessionExists(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSessionApi - object-oriented interface
 * @export
 * @class UserSessionApi
 * @extends {BaseAPI}
 */
export class UserSessionApi extends BaseAPI {
    /**
     * Checks if an active user session exists.
     * @summary Get Active User Session Exists
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSessionApi
     */
    public getActiveSessionExists(id: number, options?: any) {
        return UserSessionApiFp(this.configuration).getActiveSessionExists(id, options).then((request) => request(this.axios, this.basePath));
    }
}


